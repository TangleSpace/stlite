{"version":3,"sources":["../../../node_modules/@emotion-icons/open-iconic/ChevronTop/ChevronTop.esm.js","../../../node_modules/@emotion-icons/open-iconic/ChevronBottom/ChevronBottom.esm.js","../../../streamlit/frontend/src/components/elements/ArrowDataFrame/SortDirection.ts","../../../streamlit/frontend/src/components/elements/ArrowDataFrame/styled-components.ts","../../../streamlit/frontend/src/components/elements/ArrowDataFrame/DataFrameCell.tsx","../../../streamlit/frontend/src/components/elements/ArrowDataFrame/DataFrameUtil.tsx","../../../streamlit/frontend/src/components/elements/ArrowDataFrame/ArrowDataFrame.tsx"],"names":["ChevronTop","React","props","ref","EmotionIconBase","_extends","iconAttrs","iconVerticalAlign","iconViewBox","d","displayName","ChevronBottom","SortDirection","StyledDataFrameContainer","width","theme","border","colors","fadedText05","boxSizing","overflow","paddingRight","paddingBottom","outline","StyledDataFrameCell","padding","spacing","twoXS","xs","borderBottom","borderRight","fontSize","fontSizes","md","fontFamily","fonts","sansSerif","lineHeight","lineHeights","table","display","alignItems","justifyContent","headerCellFormatter","color","fadedText60","zIndex","cellTextFormatter","whiteSpace","textOverflow","StyledDataFrameCornerCell","StyledDataFrameColHeaderCell","userSelect","StyledDataFrameRowHeaderCell","StyledDataFrameDataCell","StyledFixup","verticalLocator","horizontalLocator","height","position","StyledEmptyDataframe","monospace","fontStyle","textAlign","StyledSortIcon","verticalAlign","DataFrameCell","onClick","role","tabIndex","CellType","columnIndex","contents","rowIndex","sortedByUser","style","columnSortDirection","className","isNumeric","id","headerClickedCallback","isHeader","data-testid","data-test-sort-direction","HeaderContentsWithTooltip","CellContentsWithTooltip","SortIcon","sortDirection","ASCENDING","Icon","content","size","margin","DESCENDING","tooltipContents","isDescending","columnName","length","Tooltip","placement","Placement","BOTTOM_LEFT","undefined","flex","AUTO","ROW_HEIGHT","smPx","getDimensions","element","cellContentsGetter","dimensions","headerRows","headerColumns","dataRows","columns","rows","headerHeight","widths","cols","headerCols","containerWidth","minWidth","maxWidth","calculateColumnWidth","colIndex","index","charWidth","maxRows","colWidth","i","Math","min","floor","random","cellWidth","distributedTable","tableColumnWidth","Array","from","_","totalTableWidth","reduce","a","b","remainingSpace","getColumnsThatExceedMaxWidth","filter","map","columnsThatExceed","remainingSpaceByColumn","keys","distributedTableTotal","elementWidth","columnWidth","headerWidth","slice","prev","curr","getWidths","totalWidth","totalHeight","maxHeight","rowHeight","typeToStyledComponent","blank","data","withFullScreenWrapper","propHeight","multiGridRef","useRef","useState","setSortedByUser","sortColumn","setSortColumn","setSortDirection","dataColumns","toggleSortOrder","newSortDirection","compareValues","type","Intl","Collator","numeric","sensitivity","compare","compareStrings","compareAny","sortedDataRowIndices","nCols","sortAscending","rowIndices","sortColumnIdx","Error","sortColumnType","Quiver","getTypeName","types","indices","sort","aRowIdx","bRowIdx","aValue","getDataValue","bValue","getSortedDataRowIndices","getDataRowIndices","sortIdx","logWarning","getCell","cssId","cssClass","contentType","displayContent","Component","format","getCellContentsGetter","cellRenderer","key","baseStyle","cellDataType","pandas_type","hasData","isLastRow","isLastCol","getCellRenderer","setTimeout","current","recomputeGridSize","useEffect","cssStyles","fixedColumnCount","fixedRowCount","columnCount","enableFixedColumnScroll","enableFixedRowScroll","rowCount","classNameBottomLeftGrid","classNameTopRightGrid","classNameBottomRightGrid"],"mappings":"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","file":"static/js/19.c70910b8.chunk.js","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport * as React from 'react';\nimport { EmotionIconBase } from '@emotion-icons/emotion-icon';\nexport var ChevronTop = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /*#__PURE__*/React.createElement(EmotionIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 8 8\"\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M4 1L0 5l1.5 1.5L4 4l2.5 2.5L8 5 4 1z\"\n  }));\n});\nChevronTop.displayName = 'ChevronTop';\nexport var ChevronTopDimensions = {\n  height: 8,\n  width: 8\n};","import _extends from \"@babel/runtime/helpers/extends\";\nimport * as React from 'react';\nimport { EmotionIconBase } from '@emotion-icons/emotion-icon';\nexport var ChevronBottom = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var attrs = {\n    \"fill\": \"currentColor\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\"\n  };\n  return /*#__PURE__*/React.createElement(EmotionIconBase, _extends({\n    iconAttrs: attrs,\n    iconVerticalAlign: \"middle\",\n    iconViewBox: \"0 0 8 8\"\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M1.5 1L0 2.5l4 4 4-4L6.5 1 4 3.5 1.5 1z\"\n  }));\n});\nChevronBottom.displayName = 'ChevronBottom';\nexport var ChevronBottomDimensions = {\n  height: 8,\n  width: 8\n};","/**\n * @license\n * Copyright 2018-2022 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum SortDirection {\n  ASCENDING = \"ascending\",\n  DESCENDING = \"descending\",\n}\n","/**\n * @license\n * Copyright 2018-2022 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport styled, { CSSObject } from \"@emotion/styled\"\nimport { Theme } from \"src/theme\"\n\nexport interface StyledDataFrameContainerProps {\n  width: number\n}\n\nexport const StyledDataFrameContainer = styled.div<\n  StyledDataFrameContainerProps\n>(({ width, theme }) => ({\n  width,\n  border: `1px solid ${theme.colors.fadedText05}`,\n  boxSizing: \"content-box\",\n\n  \"& .table-top-right\": {\n    // Hide scrollbar manually rather than with the hideTopRightGridScrollbar property of React\n    // Multigrid because the latter does show a scrollbar in some cases, for some reason.\n    overflow: \"hidden !important\",\n    paddingRight: \"6px\", // Scrollbar size\n  },\n\n  \"& .table-bottom-left\": {\n    // Hide scrollbar manually rather than with the hideTopRightGridScrollbar property of React\n    // Multigrid because the latter does show a scrollbar in some cases, for some reason.\n    overflow: \"hidden !important\",\n    paddingBottom: \"6px\", // Scrollbar size\n  },\n\n  // Only this area should ever show a scrollbar.\n  \"& .table-bottom-right\": {\n    // Like all our scrollbar mods (see globalStyles.ts) this only works in Webkit and Blink.\n    overflow: \"overlay !important\",\n  },\n\n  // Remove visible outline from click, since there's no click target/action anyway.\n  \"& .table-bottom-right:focus-visible\": {\n    outline: \"none\",\n  },\n  \"& .table-bottom-right:focus\": {\n    outline: \"none\",\n  },\n}))\n\nconst StyledDataFrameCell = styled.div(({ theme }) => ({\n  padding: `${theme.spacing.twoXS} ${theme.spacing.xs}`,\n  borderBottom: `1px solid ${theme.colors.fadedText05}`,\n  borderRight: `1px solid ${theme.colors.fadedText05}`,\n  fontSize: theme.fontSizes.md,\n  fontFamily: theme.fonts.sansSerif,\n  lineHeight: theme.lineHeights.table,\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"flex-start\",\n\n  \"&focus-visible, &:focus\": {\n    outline: \"none\",\n  },\n}))\n\nconst headerCellFormatter = (theme: Theme): CSSObject => ({\n  color: theme.colors.fadedText60,\n  borderBottom: `1px solid ${theme.colors.fadedText05}`,\n  borderRight: `1px solid ${theme.colors.fadedText05}`,\n  zIndex: 1,\n  \"&:focus-visible, &:focus\": {\n    outline: \"none\",\n  },\n})\n\nconst cellTextFormatter = (theme: Theme): CSSObject => ({\n  overflow: \"hidden\",\n  whiteSpace: \"nowrap\",\n  textOverflow: \"ellipsis\",\n  lineHeight: theme.lineHeights.table,\n})\n\nexport const StyledDataFrameCornerCell = styled(\n  StyledDataFrameCell\n)(({ theme }) => headerCellFormatter(theme))\n\nexport const StyledDataFrameColHeaderCell = styled(StyledDataFrameCell)(\n  ({ theme }) => ({\n    /* Row headers are click-to-sort, so we make the text unselectable.\n     Column headers are also unselectable, so that clicking to sort the\n     column's row header doesn't result in the entire column being selected */\n    userSelect: \"none\",\n    ...headerCellFormatter(theme),\n    ...cellTextFormatter(theme),\n  })\n)\n\nexport const StyledDataFrameRowHeaderCell = styled(StyledDataFrameCell)(\n  ({ theme }) => ({\n    /* Row headers are click-to-sort, so we make the text unselectable.\n     Column headers are also unselectable, so that clicking to sort the\n     column's row header doesn't result in the entire column being selected */\n    userSelect: \"none\",\n    ...headerCellFormatter(theme),\n    ...cellTextFormatter(theme),\n  })\n)\n\nexport const StyledDataFrameDataCell = styled(\n  StyledDataFrameCell\n)(({ theme }) => cellTextFormatter(theme))\n\nexport interface StyledFixupProps {\n  verticalLocator: \"top\" | \"bottom\"\n  horizontalLocator: \"left\" | \"right\"\n  width: number\n  height: number\n}\n\nexport const StyledFixup = styled.div<StyledFixupProps>(\n  ({ verticalLocator, horizontalLocator, width, height }) => ({\n    position: \"absolute\",\n    [verticalLocator]: \"0px\",\n    [horizontalLocator]: \"0px\",\n    width,\n    height,\n  })\n)\n\nexport const StyledEmptyDataframe = styled.div(({ theme }) => ({\n  fontFamily: theme.fonts.monospace,\n  color: theme.colors.fadedText60,\n  fontStyle: \"italic\",\n  fontSize: theme.fontSizes.md,\n  textAlign: \"center\",\n}))\n\nexport const StyledSortIcon = styled.span(({ theme }) => ({\n  color: theme.colors.fadedText05,\n  verticalAlign: \"top\",\n}))\n","/**\n * @license\n * Copyright 2018-2022 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ComponentType, ReactElement } from \"react\"\nimport { ChevronTop, ChevronBottom } from \"@emotion-icons/open-iconic\"\nimport Icon from \"src/components/shared/Icon\"\nimport Tooltip, {\n  Placement,\n  OverflowTooltip,\n  StyledEllipsizedDiv,\n} from \"src/components/shared/Tooltip\"\nimport { SortDirection } from \"./SortDirection\"\nimport { StyledSortIcon } from \"./styled-components\"\n\nexport interface DataFrameCellProps {\n  /** The cell's column index in the DataFrame */\n  columnIndex: number\n\n  /** The cell's row index in the DataFrame */\n  rowIndex: number\n\n  /** The cell's component to render */\n  CellType: ComponentType\n\n  /** Additional css styling for the cell */\n  style: React.CSSProperties\n\n  /**\n   * The HTML contents of the cell. Added to the DOM as a child of this\n   * DataFrameCell.\n   */\n  contents: string\n\n  /** The cell's CSS id */\n  id?: string\n\n  /** The cell's CSS class */\n  className: string\n\n  /** True if this cell holds a number */\n  isNumeric: boolean\n\n  /**\n   * If true, then the table's sorting was manually set by the user, by\n   * clicking on a column header. We only show the sort arrow when this is\n   * true.\n   */\n  sortedByUser: boolean\n\n  /**\n   * The {@link SortDirection} for this column, or undefined if the column is\n   * unsorted. No sorting is done here - this property is used to determine\n   * which, if any, sort icon to draw in column-header cells.\n   */\n  columnSortDirection?: SortDirection\n\n  /**\n   * An optional callback that will be called when a column header is clicked.\n   * (The property is ignored for non-header cells). The callback will be passed this\n   * cell's columnIndex.\n   *\n   * {@link DataFrame} uses this to toggle column sorting.\n   */\n  headerClickedCallback?: (columnIndex: number) => void\n}\n\nexport default function DataFrameCell({\n  CellType,\n  columnIndex,\n  contents,\n  rowIndex,\n  sortedByUser,\n  style,\n  columnSortDirection,\n  className,\n  isNumeric,\n  id,\n  headerClickedCallback,\n}: DataFrameCellProps): ReactElement {\n  const isHeader = rowIndex === 0\n\n  let onClick\n  let role\n  let tabIndex\n\n  if (headerClickedCallback != null) {\n    onClick = () => headerClickedCallback(columnIndex)\n    role = \"button\"\n    tabIndex = 0\n  }\n\n  return (\n    // (ESLint erroneously believes we're not assigning a role to our clickable div)\n    // eslint-disable-next-line\n\n    <CellType\n      // @ts-ignore\n      style={style}\n      className={className}\n      id={id}\n      onClick={onClick}\n      role={role}\n      tabIndex={tabIndex}\n      data-testid={CellType.displayName}\n      data-test-sort-direction={columnSortDirection}\n    >\n      {isHeader ? (\n        <HeaderContentsWithTooltip\n          columnIndex={columnIndex}\n          columnSortDirection={columnSortDirection}\n          contents={contents}\n          headerClickedCallback={headerClickedCallback}\n          isNumeric={isNumeric}\n          rowIndex={rowIndex}\n          sortedByUser={sortedByUser}\n        />\n      ) : (\n        <CellContentsWithTooltip contents={contents} isNumeric={isNumeric} />\n      )}\n    </CellType>\n  )\n}\n\nfunction SortIcon({\n  sortDirection,\n}: {\n  sortDirection?: SortDirection\n}): ReactElement {\n  // If these icons are changed, you may also need to update DataFrame.SORT_ICON_WIDTH\n  // to ensure proper column width padding\n  switch (sortDirection) {\n    case SortDirection.ASCENDING:\n      return (\n        <StyledSortIcon data-testid=\"sortIcon\">\n          <Icon content={ChevronTop} size=\"xs\" margin=\"0 0 0 twoXS\" />\n        </StyledSortIcon>\n      )\n\n    case SortDirection.DESCENDING:\n      return (\n        <StyledSortIcon data-testid=\"sortIcon\">\n          <Icon content={ChevronBottom} size=\"xs\" margin=\"0 0 0 twoXS\" />\n        </StyledSortIcon>\n      )\n\n    default:\n      return <></>\n  }\n}\n\ninterface HeaderContentsProps {\n  columnIndex: number\n  columnSortDirection?: SortDirection\n  contents: string\n  headerClickedCallback?: (columnIndex: number) => void\n  isNumeric: boolean\n  rowIndex: number\n  sortedByUser: boolean\n}\n\nfunction HeaderContentsWithTooltip({\n  columnIndex,\n  columnSortDirection,\n  contents,\n  headerClickedCallback,\n  isNumeric,\n  rowIndex,\n  sortedByUser,\n}: HeaderContentsProps): ReactElement {\n  let tooltipContents = contents\n\n  const isDescending = columnSortDirection === SortDirection.DESCENDING\n\n  if (headerClickedCallback != null) {\n    const columnName = contents.length ? `\"${contents}\"` : \"this index column\"\n    tooltipContents =\n      columnSortDirection == null\n        ? `Sort by ${columnName}`\n        : `Sorted by ${columnName} (${\n            isDescending ? \"descending\" : \"ascending\"\n          })`\n  }\n\n  return (\n    <Tooltip\n      content={tooltipContents}\n      placement={Placement.BOTTOM_LEFT}\n      style={{ width: \"100%\" }}\n    >\n      <StyledEllipsizedDiv\n        style={{\n          textAlign: isNumeric ? \"right\" : undefined,\n          flex: 1,\n        }}\n      >\n        {contents}\n      </StyledEllipsizedDiv>\n\n      {sortedByUser && <SortIcon sortDirection={columnSortDirection} />}\n    </Tooltip>\n  )\n}\n\ninterface CellContentsProps {\n  contents: string\n  isNumeric: boolean\n}\n\nfunction CellContentsWithTooltip({\n  contents,\n  isNumeric,\n}: CellContentsProps): ReactElement {\n  return (\n    <OverflowTooltip\n      content={contents}\n      placement={Placement.AUTO}\n      style={{\n        textAlign: isNumeric ? \"right\" : undefined,\n      }}\n    >\n      {contents}\n    </OverflowTooltip>\n  )\n}\n","/**\n * @license\n * Copyright 2018-2022 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { logWarning } from \"src/lib/log\"\nimport React, { ReactElement, ComponentType } from \"react\"\nimport { Quiver, DataFrameCellType } from \"src/lib/Quiver\"\nimport { fontSizes } from \"src/theme/primitives/typography\"\nimport {\n  StyledDataFrameRowHeaderCell,\n  StyledDataFrameDataCell,\n  StyledDataFrameColHeaderCell,\n  StyledDataFrameCornerCell,\n} from \"./styled-components\"\n\n/**\n * Size of the optional sort icon displayed in column headers\n */\nconst SORT_ICON_WIDTH_PX = 10\n\n/**\n * Height of dataframe row.\n */\nexport const ROW_HEIGHT = fontSizes.smPx * 2\n\n/*\n * Minimum size of a dataframe cell.\n */\nexport const MIN_CELL_WIDTH_PX = 25\n\n/**\n * Maximum size of a dataframe cell.\n */\nconst MAX_CELL_WIDTH_PX = 200\n\n/**\n * Maximum size of a dataframe cell in a 1-column dataframe.\n */\nconst MAX_LONELY_CELL_WIDTH_PX = 400\n\nexport interface CellContents {\n  Component: ComponentType\n  contents: string\n  cssId?: string\n  cssClass: string\n}\n\nexport interface CellContentsGetter {\n  (columnIndex: number, rowIndex: number): CellContents\n}\nexport interface CellContentsGetterProps {\n  element: Quiver\n  headerRows: number\n  sortedDataRowIndices?: number[]\n}\nexport interface CellRendererInput {\n  columnIndex: number\n  key: string\n  rowIndex: number\n  style: React.CSSProperties\n}\n\nexport interface CellRenderer {\n  (input: CellRendererInput): ReactElement\n}\n\ninterface Dimensions {\n  rowHeight: number\n  headerHeight: number\n  border: number\n  height: number\n  elementWidth: number\n  columnWidth: ({ index }: { index: number }) => number\n  headerWidth: number\n}\n\ninterface ComputedWidths {\n  elementWidth: number\n  columnWidth: ({ index }: { index: number }) => number\n  headerWidth: number\n}\n\nconst DEFAULT_HEIGHT = 300\n\n/**\n * Returns rendering dimensions for a DataFrame\n */\nexport const getDimensions = (\n  height: number | undefined,\n  width: number,\n  element: Quiver,\n  cellContentsGetter: CellContentsGetter\n): Dimensions => {\n  const {\n    headerRows,\n    headerColumns,\n    dataRows,\n    columns,\n    rows,\n  } = element.dimensions\n\n  // Rendering constants.\n  const headerHeight = ROW_HEIGHT * headerRows\n  const border = 2\n\n  // Reserve enough space to render the dataframe border as well as a vertical\n  // scrollbar if necessary.\n  const availableWidth = width - border\n  const widths = getWidths(\n    columns,\n    rows,\n    headerColumns,\n    headerRows,\n    availableWidth,\n    cellContentsGetter\n  )\n\n  let { elementWidth, columnWidth, headerWidth } = widths\n\n  // Add space for the \"empty\" text when the table is empty.\n  const EMPTY_WIDTH = 60 // px\n  if (dataRows === 0 && elementWidth < EMPTY_WIDTH) {\n    elementWidth = EMPTY_WIDTH\n    headerWidth = EMPTY_WIDTH\n    let totalWidth = 0\n    for (let i = 0; i < columns; i++) {\n      totalWidth += columnWidth({ index: i })\n    }\n    if (totalWidth < EMPTY_WIDTH) {\n      columnWidth = () => EMPTY_WIDTH / columns\n    }\n  }\n\n  // Allocate extra space for horizontal and vertical scrollbars, if needed.\n  const totalHeight = rows * ROW_HEIGHT\n  const maxHeight = (height || DEFAULT_HEIGHT) - border\n\n  height = Math.min(totalHeight, maxHeight)\n\n  return {\n    rowHeight: ROW_HEIGHT,\n    headerHeight,\n    border,\n    columnWidth,\n    headerWidth,\n    elementWidth,\n    height,\n  }\n}\n\nconst typeToStyledComponent: Record<DataFrameCellType, ComponentType> = {\n  blank: StyledDataFrameCornerCell,\n  columns: StyledDataFrameColHeaderCell,\n  index: StyledDataFrameRowHeaderCell,\n  data: StyledDataFrameDataCell,\n}\n\n/**\n * Returns a function which can access individual cell data in a DataFrame.\n *\n * The returned function has the form:\n *\n * cellContentsGetter(columnIndex: int, rowIndex: int) -> {\n *    classes: str - a css class string\n *    styles: {property1: value1, ...} - css styles to apply to the cell\n *    contents: str - the cell's formatted display string\n * }\n *\n * element              - a DataFrame\n * headerRows           - the number of frozen rows\n * headerCols           - the number of frozen columns\n * sortedDataRowIndices - (optional) an array containing an ordering for row indices\n */\nexport function getCellContentsGetter({\n  element,\n  headerRows,\n  sortedDataRowIndices,\n}: CellContentsGetterProps): CellContentsGetter {\n  return (columnIndex: number, rowIndex: number): CellContents => {\n    if (sortedDataRowIndices != null && rowIndex >= headerRows) {\n      // If we have a sortedDataRowIndices Array, it contains a mapping of row indices for\n      // all *data* (non-header) rows.\n      const sortIdx = rowIndex - headerRows\n      if (sortIdx >= 0 && sortIdx < sortedDataRowIndices.length) {\n        rowIndex = sortedDataRowIndices[sortIdx]\n        rowIndex += headerRows\n      } else {\n        logWarning(\n          `Bad sortedDataRowIndices (` +\n            `rowIndex=${rowIndex}, ` +\n            `headerRows=${headerRows}, ` +\n            `sortedDataRowIndices.length=${sortedDataRowIndices.length}`\n        )\n      }\n    }\n\n    const {\n      type,\n      cssId,\n      cssClass,\n      content,\n      contentType,\n      displayContent,\n    } = element.getCell(rowIndex, columnIndex)\n\n    // All table elements have class 'dataframe'.\n    const Component = typeToStyledComponent[type]\n\n    // Either uses Styler display values or formats the content nicely.\n    const formattedContents =\n      displayContent || Quiver.format(content, contentType)\n\n    // Put it all together\n    return { Component, contents: formattedContents, cssId, cssClass }\n  }\n}\n\n/**\n * Computes various dimensions for the table.\n *\n * First of all we create an array containing all the calculated column widths,\n * if the difference between the total of columns and the container width is negative\n * we put a width limit, if not, we divide the remaining space by each exceeding width\n */\nexport function getWidths(\n  cols: number,\n  rows: number,\n  headerCols: number,\n  headerRows: number,\n  containerWidth: number,\n  cellContentsGetter: CellContentsGetter\n): ComputedWidths {\n  const minWidth = MIN_CELL_WIDTH_PX\n  const maxWidth =\n    cols > 2 // 2 because 1 column is the index.\n      ? MAX_CELL_WIDTH_PX\n      : MAX_LONELY_CELL_WIDTH_PX\n\n  // Calculate column width based on character count alone.\n  const calculateColumnWidth = ({ index }: { index: number }): number => {\n    const colIndex = index\n    const fontSize = 10\n    const charWidth = (fontSize * 8) / 10\n    const padding = 14 + SORT_ICON_WIDTH_PX // 14 for whitespace; an extra 10 for the optional sort arrow icon\n\n    // Set the colWidth to the maximum width of a column.\n    const maxRows = 100\n    let colWidth = minWidth\n    for (let i = 0; i < Math.min(rows, maxRows); i++) {\n      let rowIndex = -1\n      if (i < headerRows) {\n        // Always measure all the header rows.\n        rowIndex = i\n      } else if (rows > maxRows) {\n        // If there are a lot of rows, then pick some at random.\n        rowIndex = Math.floor(Math.random() * rows)\n      } else {\n        // Otherwise, just measure every row.\n        rowIndex = i\n      }\n      const { contents } = cellContentsGetter(colIndex, rowIndex)\n      const nChars = contents ? contents.length : 0\n      const cellWidth = nChars * charWidth + padding\n\n      if (cellWidth > colWidth) {\n        colWidth = cellWidth\n      }\n    }\n    return colWidth\n  }\n\n  let distributedTable: Array<number> = []\n  const tableColumnWidth: Array<number> = Array.from(Array(cols), (_, index) =>\n    calculateColumnWidth({ index })\n  )\n  const totalTableWidth = tableColumnWidth.reduce((a, b) => a + b, 0)\n  const remainingSpace = containerWidth - totalTableWidth\n  const getColumnsThatExceedMaxWidth = (\n    columns: Array<number>\n  ): Array<number> => columns.filter(width => width > maxWidth)\n\n  if (remainingSpace < 0) {\n    distributedTable = tableColumnWidth.map(width =>\n      width > maxWidth ? maxWidth : width\n    )\n  } else {\n    const columnsThatExceed = getColumnsThatExceedMaxWidth(tableColumnWidth)\n    const remainingSpaceByColumn = remainingSpace / columnsThatExceed.length\n\n    distributedTable = tableColumnWidth.map((width, id) => {\n      if (id in columnsThatExceed.keys()) {\n        return width + remainingSpaceByColumn\n      }\n\n      return width\n    })\n  }\n\n  let distributedTableTotal = distributedTable.reduce((a, b) => a + b, 0)\n  if (\n    distributedTableTotal > containerWidth * (2 / 3) &&\n    distributedTableTotal < containerWidth\n  ) {\n    const remainingSpace = (containerWidth - distributedTableTotal) / cols\n    distributedTable = distributedTable.map(width => width + remainingSpace)\n    distributedTableTotal = distributedTable.reduce((a, b) => a + b, 0)\n  }\n\n  const elementWidth = Math.min(distributedTableTotal, containerWidth)\n  const columnWidth = ({ index }: { index: number }): number =>\n    distributedTable[index]\n\n  const headerWidth = distributedTable\n    .slice(0, headerCols)\n    .reduce((prev, curr) => prev + curr)\n\n  return {\n    elementWidth,\n    columnWidth,\n    headerWidth,\n  }\n}\n","/**\n * @license\n * Copyright 2018-2022 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement, useEffect, useState } from \"react\"\nimport { MultiGrid } from \"react-virtualized\"\n\nimport withFullScreenWrapper from \"src/hocs/withFullScreenWrapper\"\nimport { DataType, Quiver } from \"src/lib/Quiver\"\nimport { SortDirection } from \"./SortDirection\"\nimport DataFrameCell from \"./DataFrameCell\"\nimport {\n  CellContentsGetter,\n  CellRenderer,\n  CellRendererInput,\n  getCellContentsGetter,\n  getDimensions,\n} from \"./DataFrameUtil\"\nimport {\n  StyledDataFrameContainer,\n  StyledEmptyDataframe,\n  StyledFixup,\n} from \"./styled-components\"\n\nexport interface DataFrameProps {\n  element: Quiver\n  height?: number\n  width: number\n}\n\n/**\n * Functional element representing a DataFrame.\n */\nexport function ArrowDataFrame({\n  element,\n  height: propHeight,\n  width,\n}: DataFrameProps): ReactElement {\n  const multiGridRef = React.useRef<MultiGrid>(null)\n\n  /**\n   * If true, then the user manually clicked on a column header to sort the\n   * table.\n   */\n  const [sortedByUser, setSortedByUser] = useState(false)\n\n  /**\n   * Index of the column on which the table is sorted.\n   * (Column 0 = row indices).\n   */\n  const [sortColumn, setSortColumn] = useState(0)\n\n  /** Sort direction for table sorting. */\n  const [sortDirection, setSortDirection] = useState(SortDirection.ASCENDING)\n\n  // Calculate the dimensions of this array.\n  const {\n    headerRows,\n    headerColumns,\n    dataRows,\n    dataColumns,\n    columns,\n    rows,\n  } = element.dimensions\n\n  /**\n   * Called when one of our column headers is clicked.\n   * Changes the sort order of the table.\n   */\n  const toggleSortOrder = (columnIndex: number): void => {\n    let newSortDirection = SortDirection.ASCENDING\n    if (sortColumn === columnIndex) {\n      // Clicking the same header toggles between ascending and descending.\n      newSortDirection =\n        sortDirection === SortDirection.ASCENDING\n          ? SortDirection.DESCENDING\n          : SortDirection.ASCENDING\n    }\n    setSortColumn(columnIndex)\n    setSortDirection(newSortDirection)\n    setSortedByUser(true)\n  }\n\n  /**\n   * Returns a function that creates a DataFrameCell component for the given cell.\n   */\n  function getCellRenderer(\n    cellContentsGetter: CellContentsGetter\n  ): CellRenderer {\n    // eslint-disable-next-line react/display-name\n    return ({\n      columnIndex,\n      key,\n      rowIndex,\n      style: baseStyle,\n    }: CellRendererInput): ReactElement => {\n      const { Component, cssId, cssClass, contents } = cellContentsGetter(\n        columnIndex,\n        rowIndex\n      )\n\n      const headerClickedCallback =\n        rowIndex === 0 ? toggleSortOrder : undefined\n\n      const columnSortDirection =\n        columnIndex === sortColumn ? sortDirection : undefined\n\n      const cellDataType =\n        element.types.data[columnIndex - headerColumns]?.pandas_type\n      const isNumeric = cellDataType === \"int64\" || cellDataType === \"float64\"\n\n      const hasData = dataRows !== 0\n      const isLastRow = rowIndex === dataRows\n      const isLastCol = columnIndex === dataColumns\n\n      // Merge our base styles with any additional cell-specific\n      // styles returned by the cellContentsGetter\n      const style: React.CSSProperties = {\n        ...baseStyle,\n        borderBottom: isLastRow && hasData ? \"none\" : undefined,\n        borderRight: isLastCol ? \"none\" : undefined,\n      }\n\n      return (\n        <DataFrameCell\n          key={key}\n          CellType={Component}\n          id={cssId}\n          className={cssClass}\n          columnIndex={columnIndex}\n          rowIndex={rowIndex}\n          style={style}\n          isNumeric={isNumeric}\n          contents={contents}\n          sortedByUser={sortedByUser}\n          columnSortDirection={columnSortDirection}\n          headerClickedCallback={headerClickedCallback}\n        />\n      )\n    }\n  }\n\n  /**\n   * Returns the row indices for a DataFrame, sorted based on the values in the given\n   * columnIdx. (Note that the columnIdx is 0-based, and so does *not* include the header column;\n   * similarly, the sorted row indices will not include the header row.)\n   */\n  const getSortedDataRowIndices = (\n    sortColumnIdx: number,\n    sortAscending: boolean\n  ): number[] => {\n    if (sortColumnIdx < 0 || sortColumnIdx >= dataColumns) {\n      throw new Error(\n        `Bad sortColumnIdx ${sortColumnIdx} (should be >= 0, < ${dataColumns})`\n      )\n    }\n\n    const sortColumnType = Quiver.getTypeName(\n      element.types.data[sortColumnIdx]\n    )\n\n    const indices = new Array(dataRows)\n    for (let i = 0; i < dataRows; i += 1) {\n      indices[i] = i\n    }\n    indices.sort((aRowIdx, bRowIdx) => {\n      const aValue = element.getDataValue(aRowIdx, sortColumnIdx)\n      const bValue = element.getDataValue(bRowIdx, sortColumnIdx)\n      return sortAscending\n        ? compareValues(aValue, bValue, sortColumnType)\n        : compareValues(bValue, aValue, sortColumnType)\n    })\n\n    return indices\n  }\n\n  function compareValues(a: DataType, b: DataType, type: string): number {\n    if (type === \"unicode\") {\n      return compareStrings(a as string, b as string)\n    }\n\n    return compareAny(a, b)\n  }\n\n  function compareStrings(a: string, b: string): number {\n    const STRING_COLLATOR = new Intl.Collator(\"en\", {\n      numeric: false,\n      sensitivity: \"base\",\n    })\n\n    // using a Collator is faster than string.localeCompare:\n    // https://stackoverflow.com/questions/14677060/400x-sorting-speedup-by-switching-a-localecompareb-to-ab-1ab10/52369951#52369951\n    return STRING_COLLATOR.compare(a, b)\n  }\n\n  // Cannot enforce types here. Custom type operator overloading\n  // is not supported in TypeScript.\n  function compareAny(a: any, b: any): number {\n    if (a < b) {\n      return -1\n    }\n    if (a > b) {\n      return 1\n    }\n    return 0\n  }\n\n  /**\n   * Returns the row indices, in display order, for this DataFrame,\n   * given its sortColumn and sortDirection.\n   */\n  const getDataRowIndices = (nCols: number): number[] => {\n    const sortAscending = sortDirection !== SortDirection.DESCENDING\n\n    // If we're sorting a header column, our sorted row indices are just the\n    // row indices themselves (reversed, if SortDirection == DESCENDING)\n    if (sortColumn < headerColumns || sortColumn - headerColumns >= nCols) {\n      const rowIndices = new Array(dataRows)\n      for (let i = 0; i < dataRows; i += 1) {\n        rowIndices[i] = sortAscending ? i : dataRows - (i + 1)\n      }\n\n      return rowIndices\n    }\n\n    return getSortedDataRowIndices(sortColumn - headerColumns, sortAscending)\n  }\n\n  /**\n   * Schedule a gridSize recompute if we have a multigrid attached.\n   * This should be called whenever our data may have changed (i.e., from the render() method).\n   */\n  const recomputeSizeIfNeeded = (): void => {\n    setTimeout(() => {\n      if (multiGridRef.current != null) {\n        multiGridRef.current.recomputeGridSize()\n      }\n    }, 0)\n  }\n\n  const sortedDataRowIndices = getDataRowIndices(dataColumns)\n\n  // Get the cell renderer.\n  const cellContentsGetter = getCellContentsGetter({\n    element,\n    headerRows,\n    sortedDataRowIndices,\n  })\n\n  const cellRenderer = getCellRenderer(cellContentsGetter)\n\n  // Determine our rendering dimensions\n  const {\n    rowHeight,\n    headerHeight,\n    border,\n    height,\n    elementWidth,\n    columnWidth,\n    headerWidth,\n  } = getDimensions(propHeight, width, element, cellContentsGetter)\n\n  // Since this is a PureComponent, finding ourselves in this method\n  // means that the props have changed, so we should force a rerender of the\n  // widths.\n  recomputeSizeIfNeeded()\n\n  useEffect(() => {\n    if (sortColumn - headerColumns >= dataColumns) {\n      setSortColumn(0)\n      setSortDirection(SortDirection.ASCENDING)\n      setSortedByUser(false)\n    }\n  }, [sortColumn, headerColumns, dataColumns])\n\n  const { cssId, cssStyles } = element\n\n  // Put it all together.\n  return (\n    <StyledDataFrameContainer\n      id={cssId}\n      className=\"stDataFrame\"\n      width={elementWidth}\n    >\n      {cssStyles && <style>{cssStyles}</style>}\n      <MultiGrid\n        cellRenderer={cellRenderer}\n        fixedColumnCount={headerColumns}\n        fixedRowCount={headerRows}\n        columnWidth={columnWidth}\n        columnCount={columns}\n        enableFixedColumnScroll={false}\n        enableFixedRowScroll={false}\n        height={height}\n        rowHeight={rowHeight}\n        rowCount={rows}\n        width={elementWidth}\n        classNameBottomLeftGrid=\"table-bottom-left\"\n        classNameTopRightGrid=\"table-top-right\"\n        classNameBottomRightGrid=\"table-bottom-right\"\n        ref={multiGridRef}\n      />\n      <StyledFixup\n        verticalLocator=\"top\"\n        horizontalLocator=\"right\"\n        width={border}\n        height={headerHeight}\n      />\n      <StyledFixup\n        verticalLocator=\"bottom\"\n        horizontalLocator=\"left\"\n        width={headerWidth}\n        height={border}\n      />\n      {dataRows === 0 ? (\n        <StyledEmptyDataframe>empty</StyledEmptyDataframe>\n      ) : null}\n    </StyledDataFrameContainer>\n  )\n}\n\nexport default withFullScreenWrapper(ArrowDataFrame)\n"],"sourceRoot":""}